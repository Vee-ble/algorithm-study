### **1. 요구사항 분석**

**요구사항 요약:**

- 물병 N개(초기값 1)이고, K개의 물병을 옮길 수 있는데 물을 배분배해서 K개를 넘지 않고 비어있지 않는 물병으로 만든다.
- 재분배: 같은 양의 물병 두 개 고름 → 한개의 물병의 다른 한쪽에 있는 물을 모두 부음. 이 과정 반복한다.

만약 물병을 1개로 만드는 것이 불가능 하다면 새 물병을 구매해 합쳐가며 1개로 만든다.

**제약 사항(Constraints):**

**Input: 첫째 줄에 N과 K가 주어지고, N은 10^7보다 작거나 같은 자연수이고, k는 1,000보다 작거나 같은 자연수이다.**

Output: 첫째 줄에 상점에서 사야하는 물병의 최솟값, 정답이 없다면 -1 출력

**입출력 예시 분석:**

- `(가상의 데이터가 입력부터 출력까지 어떻게 변환되는지 서술 또는 다이어그램으로 설명)`

**예외 케이스(Edge Case):**

- `(기본 예제 제외. ex: 입력이 없거나 최소값/최대값인 경우, 중복 데이터 등)`

2 2 2 2 2 2

8 4 1 → 8 4 2 → 8 4 4 → 16

1

12 → 6 → 3

13

13 / 2 = 6 … 1 → [1]

6 / 2 = 3 … 0 → [1]

3 / 2 = 1 …. 1 → [1,4]

### **2. 해결 전략 및 자료구조 설계**

**해결 전략 (Algorithm):**

1. 현재 N의 비트 1의 개수를 센다.
2. 개수가 K보다 작거나 같다면 → 종료(구매 개수 0)
3. 개수가 K보다 크면?
   1. 새 물병을 1개 산다(answer++, N++)
   2. 합쳐지는 과정은 N이 증가하면서 자동으로 2의 제곱수 형태로 합쳐지는 것.
   3. 다시 1번으로 돌아가 확인

**예상 시간/공간 복잡도:**

데이터 흐름 시각화:

```jsx
입력: N=13, K=2
Answer = 0

loop:
	1. 13(1101) -> 1의 개수 3 (>2) -> false
		물병 구매(N=14, Answer=1)
	2. 14(1110) -> 1의 개수 3 (>2) -> false
		물병 구매(N=15, Answer=2)
	3. 15(1111) -> 1의 개수 4 (>2) -> false
		물병 구매(N=16, Answer=3)
	4. 15(10000) -> 1의 개수 1 (>2) -> true
answer 반환
```

### 3. 의사코드 & 검증

```jsx
1. let bought = 0; // 산 물병 개수

2. while
	const oneCount = N.toString(2).split("1").length -1

	if oneCount <= K 이면 break;

	N++;
	bought++

3. bought 반환
```

**Dry Run (손으로 돌려보기): N=3, K=1**

3(11), oneCount = 2 N=4, bought=1

4(100), oneCount = 1

### **4. 최종 구현 코드**

```jsx
const fs = require("fs");
const path = require("path");

const filePath =
  process.platform === "linux"
    ? "/dev/stdin"
    : path.join(__dirname, "input.txt");

const input = fs.readFileSync(filePath).toString().trim().split(" ");

let N = Number(input[0]);
const K = Number(input[1]);

let bought = 0;

while (true) {
  const oneCount = countBits(N);

  if (oneCount <= K) break;

  N++;
  bought++;
}

function countBits(num) {
  let count = 0;
  while (num > 0) {
    if (num & 1) count++;
    num >>= 1;
  }
  return count;
}

console.log(bought);
```

### 5. 트러블 슈팅 & 회고 (Retrospective)

**발생한 문제(Trouble):** 이진수의 1의 개수를 계산하는 코드의 성능이 좋지 않아서 시간 초과

**해결 과정(Shooting):** 1의 개수를 효율적으로 세는 연산 함수로 분리

1. 1씩 증가시키는 대신, 비트 연산의 성질을 이용하여 **'비트 수가 줄어드는 가장 가까운 1.다음 수'로 한 번에 점프**할 수 있는 방법이 있을까?

1씩 증가시키는 대신, **"가장 오른쪽에 있는 1(가장 작은 물병 묶음)"**을 찾아서 그만큼을 한 번에 더해주면 된다.

**원리:** 물병을 합치려면 같은 용량의 물병이 하나 더 있어야 한다 즉, 현재 가장 작은 묶음(2^i)과 똑같은 양(2^i)을 더해서 2^i+1로 만드는 것이 가장 효율적인 구매 전략이다.

**비트 연산 공식:** `N & -N` (2의 보수 성질 이용)
• 예: N = 13 (1101)
• `N & -N` = 1 (0001) → 가장 낮은 비트 추출.
• N += 1 → 14 (1110) (비트 수 3)
• `14 & -14` = 2 (0010)
• N += 2 → 16 (10000) (비트 수 1, K=2 이하 만족, 종료)

**결과:** 단 2번의 점프만으로 정답을 찾는다. 1씩 3번 더하는 것보다 훨씬 빠르며, 숫자가 클수록 차이는 극명하다.

2.N의 범위가 **10^15 (약 1000조)** 정도로 커진다면, `countBits` 함수는 의도한 대로 동작할까?

자바스크립트의 비트 연산자(`&`, `|`, `^`, `>>`, `<<`)는 피연산자를 내부적으로 **32비트 부호 있는 정수(Int32)**로 변환한 뒤 계산한다.
• 32비트 정수 범위: 약 -21억 ~ +21억.
• 만약 N이 10^15 (1000조)라면, 32비트를 넘어가는 상위 비트들은 **모두 잘려 나가고(Truncated)** 엉뚱한 값으로 계산된다.

**해결책:**

1. **BigInt 사용:** `n & 1n`, `n >> 1n` 처럼 `BigInt` 타입을 쓰면 비트 제한 없이 연산 가능.
2. **산술 연산 대체:** 비트 연산 대신 `n % 2`, `Math.floor(n / 2)`를 사용하면 64비트 부동소수점(`Number`) 범위 내에서 안전하게 계산된다.
